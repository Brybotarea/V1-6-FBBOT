'use strict';

var utils = require('../utils');

module.exports = function (defaultFuncs, api, ctx) {  
  function handleUpload(msg, form) {
    var cb;
    var rt = new Promise(function (resolve, reject) {
      cb = error => error ? reject(error) : resolve();
    });

    if (!msg.attachment) cb();
    else {
      msg.attachment = Array.isArray(msg.attachment) ? msg.attachment : [msg.attachment];
      let uploads = [];
      
      for (let attachment of msg.attachment) {
        if (!utils.isReadableStream(attachment)) 
          cb('Attachment should be a readable stream, not ' + utils.getType(attachment));

        let uploadUrl;
        let type = attachment.mimeType || utils.getType(attachment);

        if (type.startsWith("video/")) {
          uploadUrl = 'https://upload.facebook.com/ajax/react_composer/attachments/video/upload';
        } else if (type.startsWith("image/")) {
          uploadUrl = 'https://upload.facebook.com/ajax/react_composer/attachments/photo/upload';
        } else {
          cb('Unsupported attachment type: ' + type);
        }

        var uploadData = {
          source: 8,
          profile_id: ctx.userID,
          waterfallxapp: 'comet',
          farr: attachment,
          upload_id: 'jsc_c_6'
        };

        let uploadRequest = defaultFuncs
          .postFormData(uploadUrl, ctx.jar, uploadData)
          .then(utils.parseAndCheckLogin(ctx, defaultFuncs))
          .then(res => {
            if (res.error || res.errors) throw res;
            return res.payload;
          });

        uploads.push(uploadRequest);
      }

      Promise.all(uploads)
        .then(responses => {
          for (let payload of responses) {
            if (!payload) break;
            
            if (payload.photoID) {
              form.input.attachments.push({ photo: { id: payload.photoID } });
            } else if (payload.videoID) {
              form.input.attachments.push({ video: { id: payload.videoID } });
            }
          }
          return cb();
        })
        .catch(cb);
    }

    return rt;
  }

  function handleUrl(msg, form) {
    var cb;
    var rt = new Promise(function (resolve, reject) {
      cb = error => error ? reject(error) : resolve();
    });

    if (!msg.url) cb();
    else {
      var vari = {
        feedLocation: "FEED_COMPOSER",
        focusCommentID: null,
        goodwillCampaignId: "",
        goodwillCampaignMediaIds: [],
        goodwillContentType: null,
        params: {
          url: msg.url
        },
        privacySelectorRenderLocation: "COMET_COMPOSER",
        renderLocation: "composer_preview",
        parentStoryID: null,
        scale: 1,
        useDefaultActor: false,
        shouldIncludeStoryAttachment: false,
        __relay_internal__pv__IsWorkUserrelayprovider: false,
        __relay_internal__pv__IsMergQAPollsrelayprovider: false
      }
      
      defaultFuncs
        .post('https://www.facebook.com/api/graphql/', ctx.jar, {
          fb_api_req_friendly_name: 'ComposerLinkAttachmentPreviewQuery',
          variables: JSON.stringify(vari),
          server_timestamps: true,
          doc_id: 6549975235094234
        })
        .then(utils.parseAndCheckLogin(ctx, defaultFuncs))
        .then(function (res) {
          var res = (res[0] || res).data.link_preview;
          if (JSON.parse(res.share_scrape_data).share_type == 400) 
            throw { error: 'url is not accepted' }
        
          form.input.attachments.push({
            link: {
              share_scrape_data: res.share_scrape_data
            }
          });

          return cb();
        })
        .catch(cb);
    }

    return rt;
  }

  return function createPost(msg, callback) {
    var cb;
    var rt = new Promise(function (resolve, reject) {
      cb = (error, url) => url ? resolve(url) : reject(error);
    });

    if (typeof msg == 'function') {
      var error = 'Msg must be a string or object and not function';
      utils.error('createPost', error);
      return msg(error);
    }
    if (typeof callback == 'function') cb = callback;

    var typeMsg = utils.getType(msg);
    if (!['Object', 'String'].includes(typeMsg)) {
      var error = 'Msg must be a string or object and not ' + typeMsg;
      utils.error('createPost', error);
      return cb(error);
    } else if (typeMsg == 'String') msg = { body: msg };

    var form = {
      input: {
        attachments: [],
        message: {
          ranges: [],
          text: msg.body || ''
        },
        actor_id: ctx.globalOptions.pageID || ctx.userID,
      }
    }

    handleUpload(msg, form)
      .then(_ => handleUrl(msg, form))
      .then(_ => createContent(form))
      .then((res) => {
        if (res.error || res.errors) throw res;
        return cb(null, (res[0] || res).data.story_create.story.url);
      })
      .catch((err) => {
        return cb(err);
      });

    return rt;
  }
}
